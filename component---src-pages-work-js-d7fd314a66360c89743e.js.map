{"version":3,"sources":["webpack:///./src/components/createTiles.js","webpack:///./src/components/workNav.js","webpack:///./node_modules/universal-cookie/es6/utils.js","webpack:///./node_modules/universal-cookie/es6/Cookies.js","webpack:///./node_modules/universal-cookie/es6/index.js","webpack:///./src/pages/work.js","webpack:///./node_modules/cookie/index.js"],"names":["CreateTiles","props","data","tileImgs","loadTiles","state","limit","render","filter","el","undefined","forEach","previewTile","sharpImg","imageFile","childImageSharp","fluidGatsbyImage","fluid","console","log","url","src","backgroundColor","optimizedimages","colorPalette","push","componentDidMount","this","loadMore","e","preventDefault","tileData","i","setState","Fragment","className","slice","map","key","to","slug","title","dangerouslySetInnerHTML","__html","description","content","length","href","onClick","Component","disciplines","discipline","toLowerCase","hasDocumentCookie","navigator","userAgent","indexOf","isJsDom","document","cookie","readCookie","value","options","cleanValue","substr","cleanupCookieValue","doNotParse","isParsingCookie","JSON","parse","objectAssign","Cookies","cookies","_this","changeListeners","HAS_DOCUMENT_COOKIE","parseCookies","Promise","prototype","_updateBrowserValues","_emitChange","params","get","name","getAll","result","name_1","set","_a","stringify","remove","finalOptions","expires","Date","maxAge","addChangeListener","callback","removeChangeListener","idx","splice","Work","filteredTileData","allEntries","filteredArticles","categoryIndex","lastPath","categories","hasData","hasFilters","craft","entries","findFilters","filterArticles","componentWillReceiveProps","category","previews","entry","hidden","jumbledArticles","shuffleArray","array","checkCookie","temporaryValue","randomIndex","currentIndex","randomIndices","Array","item","index","Math","floor","random","tomorrow","setDate","getDate","tempArray","randIndex","seomatic","query","exports","str","TypeError","obj","opt","pairs","split","pairSplitRegExp","dec","decode","pair","eq_idx","trim","val","tryDecode","serialize","enc","encode","fieldContentRegExp","test","isNaN","Error","domain","path","toUTCString","httpOnly","secure","sameSite","decodeURIComponent","encodeURIComponent"],"mappings":"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","file":"component---src-pages-work-js-d7fd314a66360c89743e.js","sourcesContent":["import React, { Component } from 'react'\n// import PromiseImage from '../utils/PromiseImage'\n// import DelayLink from '../utils/DelayLink'\nimport { Link } from 'gatsby'\nimport Img from \"gatsby-image\"\nimport { TweenLite } from \"gsap\"\n// import NoWidows from '../utils/NoWidows'\n\nconst fadeTiming = 700;\n\nexport default class CreateTiles extends Component {\n  data;\n  tileImgs = [];\n  loadTiles = [];\n  state = {\n    limit : 32\n  }\n\n  constructor(props){\n    super();\n\n    this.data = props.render.data;\n    this.data = this.data.filter(el => {\n      return el !== undefined;\n    });\n\n    this.data.forEach(({ previewTile }) => {\n      const sharpImg = previewTile[0].imageFile.childImageSharp;\n\n      let fluidGatsbyImage = {};\n\n      if(sharpImg !== null){\n        fluidGatsbyImage.fluid = { ...sharpImg.fluid };\n      } else {\n        console.log(previewTile[0].url); // see which ones can't be converted to webp for testing\n\n        fluidGatsbyImage.fluid = { src: previewTile[0].url };\n      }\n\n      const backgroundColor = previewTile[0].optimizedimages.colorPalette[0];\n\n      fluidGatsbyImage.backgroundColor = backgroundColor ? backgroundColor : \"#efefef\"; // so it doesn't break while an image is being processed\n\n      this.tileImgs.push(fluidGatsbyImage);\n    })\n  }\n\n  componentDidMount(){\n    this.loadMore();\n  }\n\n  loadMore(e){\n    if(e){\n      e.preventDefault();\n    }\n\n    this.data.forEach((tileData, i) => {\n      if(i < this.state.limit){\n        this.loadTiles[i] = tileData;\n      }\n    })\n\n    this.setState({\n      limit: (this.state.limit + 8)\n    });\n  }\n\n  // maybe use onLoad for each image, and check against how many should load\n  // checkTilesLoaded(){\n  //   return new Promise(resolve => {\n  //     const checkLoaded = setInterval(() => {\n  //       if($(\".work-tile__image\").length !== 0){\n  //         clearInterval(checkLoaded);\n  //         resolve();\n  //       }\n  //     }, 200)\n  //   })\n  // }\n\n  // fadeOutRoute(e,to){\n  //   const clicked = $(`.work-tile[href*=\"${to}\"]`);\n\n  //   // fade everything out, but have clicked element start halfway through\n  //   $(\".work\").children().not(\".work-tile__container\").fadeOut(fadeTiming);\n  //   $(\".row\").children().not(\".work-tile__container\").fadeOut(fadeTiming);\n  //   $(\".work-tile__container\").children().not(clicked).fadeOut(fadeTiming);\n  //   $(\".home-carousel\").fadeOut(fadeTiming);\n  //   $(\".footer\").fadeOut(fadeTiming);\n  //   setTimeout(() => {\n  //     clicked.fadeOut(fadeTiming / 2);\n  //   }, fadeTiming / 2)\n  // }\n\n  // initalArticle(){\n  //   $(\".article__hero-media\").css({width:\"0%\", backgroundColor: \"unset\"});\n    \n  //   if($(\".article__hero-media\").css(\"background-image\") !== undefined && $(\".article__hero-media\").css(\"background-image\") !== \"none\"){\n\n  //     const bcgImgStripped = $(\".article__hero-media\").css(\"background-image\").replace(/^url\\([\"']?/, '').replace(/[\"']?\\)$/, '');\n\n  //     // wait till hero image has loaded before fading content in *slightly different to lazyLoad\n  //     PromiseImage.init(bcgImgStripped).then(() => {\n  //       // $(\".article__hero-media\").css({opacity:1});\n\n  //       setTimeout(() => {\n  //         TweenLite.fromTo(\n  //           $(\".article__hero-media\"), \n  //           (fadeTiming / 1000), \n  //           {width:\"1%\", opacity: 0}, \n  //           {width:\"100%\", opacity: 1, delay:(fadeTiming / 2)+\"s\", ease: 'Expo.easeOut'}\n  //         );\n  \n  //         setTimeout(() => {\n  //           $(\".article\").children().fadeIn(fadeTiming);\n  //           $(\".footer\").fadeIn(fadeTiming);\n  //           LazyLoad.init();\n  //         },fadeTiming + 400)\n  //       }, fadeTiming)\n  //     });\n  //   } else {\n  //     setTimeout(() => { // hotfix, hero hasn't loaded whjen this is called\n  //       this.initalArticle();\n  //     },100)\n  //   }\n  // }\n\n  render() {\n    console.log('this.loadTiles',this.loadTiles);\n    return (\n      <React.Fragment>\n        <div className=\"work-tile__container\">\n          {this.loadTiles.slice( 0, this.state.limit ).map((data, i) => (\n            <Link className=\"work-tile\" key={`home tile ${i}`} to={`/work/articles/${data.slug}`}>\n              <Img className={\"work-tile__image aspect__2-by-1 hover-cursor\"} { ...this.tileImgs[i] }/>\n              <p className=\"work-tile__client fontSize-p3 fontSize-uppercase\"> { data.title } </p>\n              <p className=\"work-tile__title fontSize-p2\" dangerouslySetInnerHTML={{ __html: data.description !== null ? data.description.content : null }}/>\n            </Link>\n          ))} \n        </div>\n\n        {this.data.length > this.loadTiles.length ? (\n          <div className=\"work-tile__load-more\">\n            <a href=\"\" onClick={ e => { this.loadMore(e) }} className=\"work-tile__load-more-button fontSize-p2\">Load more work</a>\n          </div>\n        ) : (\n          <div className=\"work-tile__load-more\"/>\n        )}\n      </React.Fragment>\n    );\n  }\n}","import React from 'react'\nimport { Link } from 'gatsby'\n\nexport default ({ render }) => (\n  <div className=\"work__nav\">\n    <div className=\"work__nav-disciplines\">\n      <Link className=\"work__nav-disciplines-link\" to={`/work`}>\n        <h3 className=\"work__nav-disciplines-text fontSize-p2\">All</h3>\n      </Link> \n\n      {render.disciplines.map((discipline, i) => {\n        return (\n          <Link className=\"work__nav-disciplines-link\" key={discipline} to={ `/work/${discipline.toLowerCase()}` }> \n            <h3 className=\"work__nav-disciplines-text fontSize-p2\">{ discipline }</h3> \n          </Link>\n        )\n      })} \n    </div>\n\n    {/* <div className=\"work__nav-tags\">\n      {props.render.categories.map((tag, i) => {\n        return (\n          <Link className=\"work__nav-tags-link\" key={tag} to={ `/work/${tag.toLowerCase()}` }> \n            <h3 className=\"work__nav-tags-text fontSize-p2\">{ tag }</h3> \n          </Link>\n        )\n      })} \n    </div> */}\n  </div>\n)","import \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.array.index-of\";\nimport * as cookie from 'cookie';\nexport function hasDocumentCookie() {\n  // JSDOM does not support changing cookies, disable it for tests\n  if (isJsDom()) {\n    return false;\n  } // Can we get/set cookies on document.cookie?\n\n\n  return typeof document === 'object' && typeof document.cookie === 'string';\n}\n\nfunction isJsDom() {\n  if (typeof navigator !== 'object' || typeof navigator.userAgent !== 'string') {\n    return false;\n  }\n\n  return navigator.userAgent.indexOf('Node.js') >= 0 || navigator.userAgent.indexOf('jsdom') >= 0;\n}\n\nexport function cleanCookies() {\n  document.cookie.split(';').forEach(function (c) {\n    document.cookie = c.replace(/^ +/, '').replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');\n  });\n}\nexport function parseCookies(cookies) {\n  if (typeof cookies === 'string') {\n    return cookie.parse(cookies);\n  } else if (typeof cookies === 'object' && cookies !== null) {\n    return cookies;\n  } else {\n    return {};\n  }\n}\nexport function isParsingCookie(value, doNotParse) {\n  if (typeof doNotParse === 'undefined') {\n    // We guess if the cookie start with { or [, it has been serialized\n    doNotParse = !value || value[0] !== '{' && value[0] !== '[' && value[0] !== '\"';\n  }\n\n  return !doNotParse;\n}\nexport function readCookie(value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var cleanValue = cleanupCookieValue(value);\n\n  if (isParsingCookie(cleanValue, options.doNotParse)) {\n    try {\n      return JSON.parse(cleanValue);\n    } catch (e) {// At least we tried\n    }\n  } // Ignore clean value if we failed the deserialization\n  // It is not relevant anymore to trim those values\n\n\n  return value;\n}\n\nfunction cleanupCookieValue(value) {\n  // express prepend j: before serializing a cookie\n  if (value && value[0] === 'j' && value[1] === ':') {\n    return value.substr(2);\n  }\n\n  return value;\n}","import \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/es6.promise\";\nimport \"core-js/modules/es6.object.to-string\";\nimport * as cookie from 'cookie';\nimport { parseCookies, readCookie, hasDocumentCookie } from './utils'; // We can't please Rollup and TypeScript at the same time\n// Only way to make both of them work\n\nvar objectAssign = require('object-assign');\n\nvar Cookies =\n/** @class */\nfunction () {\n  function Cookies(cookies) {\n    var _this = this;\n\n    this.changeListeners = [];\n    this.HAS_DOCUMENT_COOKIE = false;\n    this.cookies = parseCookies(cookies);\n    new Promise(function () {\n      _this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();\n    })[\"catch\"](function () {});\n  }\n\n  Cookies.prototype._updateBrowserValues = function () {\n    if (!this.HAS_DOCUMENT_COOKIE) {\n      return;\n    }\n\n    this.cookies = cookie.parse(document.cookie);\n  };\n\n  Cookies.prototype._emitChange = function (params) {\n    for (var i = 0; i < this.changeListeners.length; ++i) {\n      this.changeListeners[i](params);\n    }\n  };\n\n  Cookies.prototype.get = function (name, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._updateBrowserValues();\n\n    return readCookie(this.cookies[name], options);\n  };\n\n  Cookies.prototype.getAll = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._updateBrowserValues();\n\n    var result = {};\n\n    for (var name_1 in this.cookies) {\n      result[name_1] = readCookie(this.cookies[name_1], options);\n    }\n\n    return result;\n  };\n\n  Cookies.prototype.set = function (name, value, options) {\n    var _a;\n\n    if (typeof value === 'object') {\n      value = JSON.stringify(value);\n    }\n\n    this.cookies = objectAssign({}, this.cookies, (_a = {}, _a[name] = value, _a));\n\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = cookie.serialize(name, value, options);\n    }\n\n    this._emitChange({\n      name: name,\n      value: value,\n      options: options\n    });\n  };\n\n  Cookies.prototype.remove = function (name, options) {\n    var finalOptions = options = objectAssign({}, options, {\n      expires: new Date(1970, 1, 1, 0, 0, 1),\n      maxAge: 0\n    });\n    this.cookies = objectAssign({}, this.cookies);\n    delete this.cookies[name];\n\n    if (this.HAS_DOCUMENT_COOKIE) {\n      document.cookie = cookie.serialize(name, '', finalOptions);\n    }\n\n    this._emitChange({\n      name: name,\n      value: undefined,\n      options: options\n    });\n  };\n\n  Cookies.prototype.addChangeListener = function (callback) {\n    this.changeListeners.push(callback);\n  };\n\n  Cookies.prototype.removeChangeListener = function (callback) {\n    var idx = this.changeListeners.indexOf(callback);\n\n    if (idx >= 0) {\n      this.changeListeners.splice(idx, 1);\n    }\n  };\n\n  return Cookies;\n}();\n\nexport default Cookies;","import Cookies from './Cookies';\nexport default Cookies;","import React, { Component } from 'react'\n\nimport Layout from \"../components/layout\"\nimport SEO from \"../components/seo\"\nimport WorkNav from '../components/workNav'\nimport CreateTiles from '../components/createTiles'\nimport Cookies from 'universal-cookie'\n\nexport default class Work extends Component {\n  filteredTileData;\n  allEntries;\n  filteredArticles = [];\n  categoryIndex;\n  lastPath;\n  disciplines = [];\n  categories = [];\n  cookies = new Cookies();\n\n  state = {\n    hasData : false,\n    hasFilters: false\n  }\n\n  componentDidMount(){\n    this.allEntries  = this.props.data.craft.entries;\n\n    this.findFilters();\n    this.filterArticles();\n  }\n\n  // chnage to click, and get href of clicked\n  componentWillReceiveProps(){\n    // setTimeout(() => {\n    //   let pathName = this.props.history.location.pathname;\n    //   // if the page hasn't changed prevent infinite reloads\n    //   if(this.lastPath !== pathName){\n    //     $(\".work-tile__container\").fadeOut(400);\n    //     setTimeout(() => {\n    //       this.setState({ \"hasData\" : false });\n    //       this.filteredArticles = [];\n    //       this.filterArticles();\n    //     },400)\n    //   }\n    // },40)\n  }\n\n  findFilters(){\n    let entries = this.allEntries;\n\n    entries.forEach(({ disciplines, categories }) => {\n      disciplines.forEach(({ title }) => {\n        let discipline = title.toLowerCase();\n\n        if(this.disciplines.indexOf(discipline) === -1){\n          this.disciplines.push(discipline);\n        }\n      })\n\n      categories.forEach(({ title }) => {\n        let category = title.toLowerCase();\n\n        if(this.categories.indexOf(category) === -1){\n          this.categories.push(category);\n        }\n      })\n    })\n\n    // for now this is fixed to these\n    this.disciplines = [\n      \"brand & identity\",\n      \"film & photography\",\n      \"spatial\",\n      \"digital\"\n    ]\n\n    this.setState({ \"hasFilters\" : true });\n  }\n\n  filterArticles(){\n\n    // ------------------------------------------------------------------------\n    // filter used to be based on routes, now need to create static pages somehwo\n    // ------------------------------------------------------------------------\n\n\n    // this.lastPath = this.props.history.location.pathname;\n\n    // let filter = this.lastPath.split(\"/\")[2],\n    let entries = this.allEntries,\n        previews = [];\n\n    entries = entries.filter(entry => {\n      if(entry.hidden === true){\n        previews.push(entry) \n      } else {return true} \n    });\n\n    // if(filter !== undefined){\n    //   filter.toLowerCase();\n\n    //   for(let i = 0; i < entries.length; i++){\n    //     let found = false; \n\n    //     for(let j = 0; j < entries[i].disciplines.length; j++){\n    //       let discipline = entries[i].disciplines[j].title.toLowerCase();\n\n    //       if(!found && discipline === filter){\n    //         found = true;\n    //       }\n    //     }\n\n    //     for(let j = 0; j < entries[i].categories.length; j++){\n    //       let category = entries[i].categories[j].title.toLowerCase();\n\n    //       if(!found && category === filter){\n    //         found = true;\n    //       }\n    //     }\n\n    //     if(found){\n    //       this.filteredArticles.push(entries[i]);\n    //     }\n    //   }\n    // } else {\n      let jumbledArticles = this.shuffleArray(entries);\n      this.filteredArticles = jumbledArticles;\n    // }\n\n    if(this.filteredArticles.length > 0){\n      this.setState({ \"hasData\" : true });\n\n      // $(`.work__nav-disciplines-link`).removeClass(\"-active\");\n      // $(`.work__nav-disciplines-link[href=\"${this.lastPath}\"]`).addClass(\"-active\");\n      // $(`.work__nav-tags-link`).removeClass(\"-active\");\n      // $(`.work__nav-tags-link[href=\"${this.lastPath}\"]`).addClass(\"-active\");\n      // this.props.update(Math.random())\n    }\n  }\n\n  shuffleArray(array){\n    let checkCookie = this.cookies.get('dwTiles');\n\n    if(checkCookie === undefined){\n      let currentIndex = array.length, \n          temporaryValue, \n          randomIndex, \n          randomIndices = new Array(array.length);\n\n      array.forEach((item, i) => {\n        item.index = i;\n      })\n\n      // While there remain elements to shuffle...\n      while (0 !== currentIndex) {\n\n        // Pick a remaining element...\n        randomIndex = Math.floor(Math.random() * currentIndex);\n        currentIndex -= 1;\n\n        // And swap it with the current element.\n        temporaryValue = array[currentIndex];\n        array[currentIndex] = array[randomIndex];\n        array[randomIndex] = temporaryValue;\n      }\n\n      array.forEach((item, i) => {\n        randomIndices[i] = item.index;\n      })\n\n      // set cookie so tiles only randomised once a day\n      let tomorrow = new Date();\n      tomorrow.setDate(tomorrow.getDate() + 1);\n\n      this.cookies.set('dwTiles', JSON.stringify(randomIndices),{\n        expires: tomorrow\n      });\n    } else {\n      let tempArray = new Array(checkCookie.length);\n\n      checkCookie.forEach((randIndex, i) => {\n        tempArray[i] = array[randIndex];\n      })\n      \n      array = tempArray;\n    }\n\n    return array;\n  }\n\n  render() {\n    const seomatic = this.props.data.craft.seomatic,\n          hasData = this.state.hasData,\n          hasFilters = this.state.hasFilters;\n\n    return (\n      <Layout className=\"work\">\n        <SEO data={ seomatic }/>\n        {hasFilters && (\n          <WorkNav render={{ disciplines: this.disciplines, categories: this.categories }}/>\n        )}\n\n        {hasData && (            \n          <CreateTiles render={{ data: this.filteredArticles }}/>\n        )}\n      </Layout>\n    );\n  }\n}\n\nexport const query = graphql`\n  query {\n    craft {\n      seomatic(uri: \"/work\") {\n        metaTitleContainer\n        metaTagContainer\n        metaLinkContainer\n        metaScriptContainer\n        metaJsonLdContainer\n      }\n      entries(section: [projects], hidden: false) {\n        ... on Craft_Projects {\n          hidden\n          slug\n          title\n          previewTile {\n            url\n            width\n            height\n            ... on Craft_UploadsVolume {\n              url\n\n              imageFile {\n                childImageSharp {\n                  fluid(maxWidth: 650) {\n                    ...GatsbyImageSharpFluid_withWebp_noBase64\n                  }\n                }\n              }\n\n              optimizedimages {\n                colorPalette\n              }\n            }\n          }\n          description {\n            content\n          }\n          categories {\n            title\n          }\n          disciplines {\n            title\n          }\n        }\n      }\n    }\n  }    \n`;","/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n'use strict';\n/**\n * Module exports.\n * @public\n */\n\nrequire(\"core-js/modules/es6.string.trim\");\n\nrequire(\"core-js/modules/es6.array.index-of\");\n\nrequire(\"core-js/modules/es6.regexp.split\");\n\nexports.parse = parse;\nexports.serialize = serialize;\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar pairSplitRegExp = /; */;\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {};\n  var opt = options || {};\n  var pairs = str.split(pairSplitRegExp);\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var eq_idx = pair.indexOf('='); // skip things that don't look like key=value\n\n    if (eq_idx < 0) {\n      continue;\n    }\n\n    var key = pair.substr(0, eq_idx).trim();\n    var val = pair.substr(++eq_idx, pair.length).trim(); // quoted values\n\n    if ('\"' == val[0]) {\n      val = val.slice(1, -1);\n    } // only assign once\n\n\n    if (undefined == obj[key]) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n\n      case 'none':\n        str += '; SameSite=None';\n        break;\n\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}"],"sourceRoot":""}